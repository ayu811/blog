---
title: コンパイラ作成に必要なx86のアセンブリ知識
image: ./images/python.jpg
# imageAttribution: none needed for this post
date: 2024-12-27
category: Technology
trending: false
topPick: false
popular: true
---

## アセンブリ言語の世界へ飛び込もう！x86 の基本をわかりやすく解説

「低レイヤー」とか「機械に近い言語」なんて聞くと、なんだか難しそう…って思いますよね？ でも大丈夫！ この記事では、そんなアセンブリ言語の入り口を、図解もたっぷり使って、誰でも理解できるように優しくご案内します。 今回は、x86 アーキテクチャのアセンブリ言語にスポットライトを当てて、その基本のキを一緒に見ていきましょう！

### アセンブリ言語って何？

まず最初に、アセンブリ言語が一体何なのか、簡単に説明しますね。

突然ですが、皆さんのパソコンの中身ってどうなってるか想像したことありますか？ 僕たちが普段書いている C++や Python のようなプログラミング言語は、実はコンピュータが直接理解できる言葉ではありません。

そこで登場するのが**コンパイラ**さん！ コンパイラは、僕たちが書いたコードを、コンピュータが直接理解できる**機械語**というものに翻訳してくれるんです。

そして、**アセンブリ言語**は、この機械語にほぼ一対一に対応した、人間が理解しやすい形にした言語なんです。 機械語は 0 と 1 の羅列なので、人間にはちょっと厳しい…そこで、アセンブリ言語の出番というわけです！
_イメージ: プログラミング言語 -> コンパイラ -> アセンブリ言語 -> アセンブラ -> 機械語_

### アセンブリ言語の基本構文を覗いてみよう！

アセンブリ言語のコードは、主に**命令**と**擬似命令**で構成されています。

- **命令 (Instruction)**: これは CPU に対する具体的な指示です。「データをどこかに移動して！」とか「この数とあの数を足して！」といった命令を書きます。
- **擬似命令 (Directive)**: こちらはアセンブラ（アセンブリ言語を機械語に変換するプログラム）に対する指示です。「ここにデータを置いてね」とか「この名前で処理を開始してね」といったことを伝えます。

基本的な命令の書き方はこんな感じです。

```assembly
ニーモニック  オペランド1, オペランド2
```

- **ニーモニック (mnemonic)**: 命令の種類を表す短い英単語みたいなものです。例えば、`mov`（ムーブ、移動）、`add`（アド、加算）などがあります。
- **オペランド (operand)**: 命令の対象となるデータや場所です。「どこからどこへ移動するの？」とか「どの数とどの数を足すの？」といった情報を指定します。

例を見てみましょう！

```assembly
mov rax, 10    ; raxレジスタに10を代入！
add rbx, rcx   ; rbxレジスタの値にrcxレジスタの値を足す！
```

コメントはセミコロン `;` の後に入力します。コードの意味を説明するのに役立ちますね。

### x86 アセンブリ言語の主要な命令たち

x86 アセンブリ言語にはたくさんの命令がありますが、ここでは特に重要なものをいくつかピックアップしてご紹介します。

#### データ転送命令： データをあっちからこっちへ！

| ニーモニック | 説明                             | 例                                       |
| :----------- | :------------------------------- | :--------------------------------------- |
| `mov`        | データをコピーします             | `mov rax, rbx` (rbx の値を rax にコピー) |
| `push`       | データをスタックに積みます       | `push rax` (rax の値をスタックへ)        |
| `pop`        | データをスタックから取り出します | `pop rbx` (スタックから値を rbx へ)      |

_イメージ: スタックにデータが積み重なっていく様子と、上から順番に取り出される様子_

#### 算術演算命令： 計算はおまかせ！

| ニーモニック | 説明                        | 例                                  |
| :----------- | :-------------------------- | :---------------------------------- |
| `add`        | 足し算を行います            | `add rax, rbx` (rax += rbx)         |
| `sub`        | 引き算を行います            | `sub rax, rbx` (rax -= rbx)         |
| `mul`        | 掛け算を行います (符号なし) | `mul rbx` (rax \*= rbx)             |
| `imul`       | 掛け算を行います (符号付き) | `imul rax, rbx` (rax \*= rbx)       |
| `div`        | 割り算を行います (符号なし) | `div rbx` (rax /= rbx, 余りは rdx)  |
| `idiv`       | 割り算を行います (符号付き) | `idiv rbx` (rax /= rbx, 余りは rdx) |

#### 論理演算命令： 真偽を操る！

| ニーモニック | 説明                | 例                          |
| :----------- | :------------------ | :-------------------------- |
| `and`        | 論理積（AND）       | `and rax, rbx` (rax &= rbx) |
| `or`         | 論理和（OR）        | `or rax, rbx` (rax \|= rbx) |
| `xor`        | 排他的論理和（XOR） | `xor rax, rbx` (rax ^= rbx) |
| `not`        | 否定（NOT）         | `not rax` (rax = ~rax)      |

#### 制御フロー命令： プログラムの流れをコントロール！

| ニーモニック | 説明                                  | 例                      |
| :----------- | :------------------------------------ | :---------------------- |
| `jmp`        | 無条件ジャンプ                        | `jmp label`             |
| `je`         | 等しい時にジャンプ (Zero Flag が立つ) | `je equal_label`        |
| `jne`        | 等しくない時にジャンプ                | `jne not_equal_label`   |
| `jl`         | より小さい時にジャンプ                | `jl less_than_label`    |
| `jg`         | より大きい時にジャンプ                | `jg greater_than_label` |
| `call`       | サブルーチン（関数）呼び出し          | `call my_function`      |
| `ret`        | サブルーチンからの復帰                | `ret`                   |

### レジスタはデータの相棒！

**レジスタ**は、CPU の中にある高速な記憶領域です。よく使うデータや計算途中のデータを一時的に置いておくのに使われます。 x86-64 アーキテクチャには、たくさんのレジスタがありますが、特に重要な汎用レジスタを見てみましょう。

![x86-64レジスタのイメージ]

- `rax`: アキュムレータ (accumulator) と呼ばれ、演算結果の格納などによく使われます。関数の戻り値もここに入ることが多いです。
- `rbx`: ベースレジスタ (base register) として、メモリアドレスの計算などに使われます。
- `rcx`: カウンタレジスタ (counter register) として、ループ処理の回数を数えるのによく使われます。
- `rdx`: データレジスタ (data register) として、`mul`や`div`命令で`rax`と組み合わせて使われたりします。
- `rsi`, `rdi`: それぞれソースインデックス (source index)、デスティネーションインデックス (destination index) として、文字列操作などでデータの読み出し元や書き込み先のアドレスを指すのに使われます。
- `rbp`: ベースポインタ (base pointer) として、スタックフレームの基準点を示すのに使われます。
- `rsp`: スタックポインタ (stack pointer) として、スタックの現在位置を示すのに使われます。 **絶対に間違って操作しないように！**
- `r8` ~ `r15`: 追加された汎用レジスタです。

これらのレジスタは、64 ビットのデータを格納できます。 また、それぞれのレジスタの下位の部分 (32 ビット, 16 ビット, 8 ビット) にも名前がついていて、個別にアクセスすることも可能です。 例えば、`rax` の下位 32 ビットは `eax`、16 ビットは `ax`、下位 8 ビットは `al` といった具合です。

### メモリへのアクセス： データは宝の山！

プログラムで扱うデータは、普段は**メモリ**という場所に保管されています。 レジスタは CPU 内部の高速な記憶領域でしたが、メモリはもっとたくさんのデータを保管できる場所です。

アセンブリ言語でメモリにアクセスするには、アドレスを指定する必要があります。 アドレスは、レジスタの値を使ったり、直接数値を書いたり、計算したりして指定できます。

```assembly
mov rax, [rbx]      ; rbxレジスタに入っているアドレスからデータを読み込んでraxに入れる
mov [rdi], rcx     ; rcxレジスタの値が指すデータを、rdiレジスタに入っているアドレスのメモリに書き込む
mov rdx, [rsi+8]    ; rsiレジスタの値に8を足したアドレスからデータを読み込んでrdxに入れる
mov [rbp-16], 10   ; rbpレジスタの値から16を引いたアドレスに10という値を書き込む
```

角括弧 `[]` で囲むと、「そこに入っているアドレスが示すメモリの中身」という意味になります。

### 簡単なアセンブリ言語プログラムを見てみよう！

百聞は一見に如かず！ 実際に簡単なアセンブリ言語のプログラムを見て、実行してみましょう。 今回は、2 つの数値を足し算して結果を表示するプログラムを作ってみます。

```assembly
section .data
    num1 dq 10      ; 8バイトの領域に10を格納
    num2 dq 20      ; 8バイトの領域に20を格納
    msg db "The sum is: %ld", 10, 0  ; メッセージと改行コード

section .text
    global main
    extern printf    ; 外部関数の宣言

main:
    push rbp        ; ベースポインタをスタックに保存
    mov rbp, rsp    ; スタックポインタをベースポインタにコピー

    mov rax, [num1] ; num1の値をraxレジスタにロード
    add rax, [num2] ; num2の値をraxレジスタに加算

    ; printf関数を呼び出す準備
    mov rdi, msg    ; 第1引数: フォーマット文字列
    mov rsi, rax    ; 第2引数: 計算結果
    xor rax, rax    ; 可変長引数の個数を設定 (ここでは0)
    call printf     ; printf関数を呼び出し

    mov rsp, rbp    ; スタックポインタを元に戻す
    pop rbp         ; ベースポインタを元に戻す
    ret             ; プログラム終了
```

このコードをアセンブルして実行するには、いくつかの手順が必要です。

1. **アセンブラ (nasm) のインストール:** もしインストールされていなければ、インストールしましょう。
2. **コードを保存:** 上記のコードを `program.asm` などの名前で保存します。
3. **アセンブル:** ターミナルで以下のコマンドを実行します。

   ```bash
   nasm -f elf64 program.asm -o program.o
   ```

4. **リンク:** 次に、生成されたオブジェクトファイルと標準ライブラリをリンクします。

   ```bash
   gcc program.o -o program
   ```

5. **実行:** 以下のコマンドでプログラムを実行できます。

   ```bash
   ./program
   ```

実行すると、「The sum is: 30」と表示されるはずです！ やったね！

### まとめ： アセンブリ言語への第一歩

今回の記事では、x86 アセンブリ言語の基本的な部分を、できるだけ分かりやすく解説してみました。 最初はとっつきにくいかもしれませんが、一つ一つの命令やレジスタの役割を理解していくことで、コンピュータがどのように動いているのか、より深く理解できるようになります。

アセンブリ言語を学ぶことは、プログラミングの基礎を固める上で非常に役立ちます。 この記事が、皆さんのアセンブリ言語学習の第一歩になれば嬉しいです！

さらに深く学びたい方は、参考文献やオンラインリソースを参考に、色々なアセンブリ言語のコードを読んでみたり、実際に自分で書いて動かしてみることをお勧めします。 Let's enjoy the low-level world!
